<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
  <meta name="theme-color" content="#121212">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AHSS - Double Elimination Brackets</title>

  <style>
    :root{
      --bg:#121212;
      --panel:#0f0f10;
      --panel2:#141415;
      --border:#2d2f33;
      --text:#f0f0f0;
      --muted:#a7abcc;
      --teamA:#d32f2f;
      --teamB:#1976d2;
      --good:#3ddc84;
      --warn:#f2c94c;
      --bad:#ff5252;
      --radius:14px;
      --shadow:0 14px 40px rgba(0,0,0,.45);
    }

    *{ box-sizing:border-box; }
    html,body{
      margin:0;
      padding:0;
      background:var(--bg);
      color:var(--text);
      font-family: Arial, sans-serif;
      touch-action: manipulation;
    }

    .wrap{
      max-width:1200px;
      margin:0 auto;
      padding:18px 16px 80px;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:14px;
      flex-wrap:wrap;
      margin-bottom:14px;
    }

    .brand{
      display:flex;
      align-items:center;
      gap:12px;
    }
    .brand img{
      max-width:160px;
      height:auto;
    }
    .brand h1{
      margin:0;
      font-size:18px;
      letter-spacing:.3px;
    }
    .brand .sub{
      margin:2px 0 0;
      color:rgba(255,255,255,.65);
      font-size:13px;
    }

    .card{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }

    .card-h{
      padding:12px 14px;
      border-bottom:1px solid rgba(255,255,255,.08);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      background:linear-gradient(180deg, rgba(255,255,255,.04), transparent);
    }
    .card-h h2{
      margin:0;
      font-size:15px;
      letter-spacing:.3px;
    }

    .card-b{ padding:14px; }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
    }
    @media (min-width: 980px){
      .grid{ grid-template-columns: 420px 1fr; align-items:start; }
    }

    .controls{
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    label{
      display:block;
      font-size:12px;
      color:rgba(255,255,255,.72);
      margin-bottom:6px;
    }

    select, input[type="number"], textarea{
      width:100%;
      background:var(--panel2);
      border:1px solid rgba(255,255,255,.12);
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      outline:none;
      font-size:14px;
    }

    textarea{
      min-height:160px;
      resize:vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      line-height:1.35;
    }

    .btn{
      border:none;
      border-radius:12px;
      padding:10px 12px;
      cursor:pointer;
      font-weight:800;
      font-size:13px;
      letter-spacing:.2px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      background:#1f1f1f;
      color:#fff;
      border:1px solid rgba(255,255,255,.14);
    }
    .btn:hover{ opacity:.92; }
    .btn:disabled{ opacity:.45; cursor:not-allowed; }

    .btn-primary{
      background: linear-gradient(90deg, var(--teamA), #ffffff, var(--teamB));
      color:#000;
      border:none;
    }

    .btn-ghost{
      background:transparent;
      border:1px solid rgba(255,255,255,.14);
      color:#fff;
    }

    .pillbar{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:10px;
    }
    .pill{
      padding:6px 10px;
      border-radius:999px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      color:#fff;
      font-size:12px;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .pill .x{
      width:18px; height:18px;
      border-radius:50%;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      background:rgba(255,255,255,.10);
      cursor:pointer;
      user-select:none;
      font-weight:900;
    }

    .status{
      font-size:12px;
      color:rgba(255,255,255,.72);
      margin-top:8px;
    }

    /* Bracket area */
    .bracket-wrap{
      overflow:auto;
      padding-bottom:8px;
    }

    .bracket{
      min-width:900px;
      display:flex;
      gap:22px;
      padding:10px 6px 6px;
      align-items:flex-start;
    }

    .col{
      display:flex;
      flex-direction:column;
      gap:14px;
      min-width:260px;
    }

    .col-title{
      font-size:12px;
      color:rgba(255,255,255,.7);
      letter-spacing:.4px;
      text-transform:uppercase;
      margin-left:6px;
    }

    .match{
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      padding:10px;
    }

    .match-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
      color:rgba(255,255,255,.75);
      font-size:12px;
    }
    .match-head .tag{
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.05);
      font-weight:800;
      color:#fff;
      font-size:11px;
      letter-spacing:.2px;
    }

    .slot{
      display:grid;
      grid-template-columns: 1fr 40px 40px;
      gap:8px;
      align-items:center;
      margin-bottom:8px;
      padding:8px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.20);
    }

    .slot:last-child{ margin-bottom:0; }

    .name{
      font-weight:900;
      font-size:13px;
      line-height:1.1;
    }
    .seed{
      font-size:11px;
      color:rgba(255,255,255,.55);
      margin-top:2px;
    }

    .score{
      width:40px;
      text-align:center;
      padding:8px 6px;
      border-radius:10px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      color:#fff;
      font-weight:900;
      outline:none;
    }

    .btn-mini{
      padding:8px 10px;
      border-radius:10px;
      font-weight:900;
      font-size:12px;
      background:#1f1f1f;
      color:#fff;
      border:1px solid rgba(255,255,255,.14);
      cursor:pointer;
    }

    .btn-win{ background:rgba(61,220,132,.18); border-color:rgba(61,220,132,.35); }
    .btn-lose{ background:rgba(255,82,82,.12); border-color:rgba(255,82,82,.35); }

    .slot.win{
      border-color: rgba(61,220,132,.55);
      box-shadow: 0 0 0 1px rgba(61,220,132,.18) inset;
    }
    .slot.lose{
      opacity:.78;
      border-color: rgba(255,255,255,.08);
    }

    .footerbar{
      position:fixed;
      left:0; right:0; bottom:0;
      background:rgba(10,10,12,.92);
      border-top:1px solid rgba(255,255,255,.10);
      padding:10px 14px;
      backdrop-filter: blur(10px);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      z-index:999;
    }
    .footerbar .left{
      font-size:12px;
      color:rgba(255,255,255,.65);
      line-height:1.2;
    }
    .footerbar .right{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .tiny{
      font-size:11px;
      color:rgba(255,255,255,.55);
    }

    .note{
      padding:10px 12px;
      border-radius:14px;
      border:1px dashed rgba(255,255,255,.22);
      background:rgba(245,192,79,.08);
      color:#f5c04f;
      font-weight:800;
      font-size:13px;
    }

    .kbd{
      padding:2px 6px;
      border:1px solid rgba(255,255,255,.18);
      border-radius:6px;
      background:rgba(255,255,255,.06);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:11px;
      color:#fff;
    }

    /* Hide scrollbars gently (still scrollable) */
    .bracket-wrap::-webkit-scrollbar{ height:10px; }
    .bracket-wrap::-webkit-scrollbar-thumb{ background:#2c2c2c; border-radius:999px; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <img id="appLogo" src="logo.png" alt="AHSS Logo" />
        <div>
          <h1>Double Elimination Brackets</h1>
          <div class="sub">Built for AHSS - pulls tonight’s signups from AYPT Google Sheet</div>
        </div>
      </div>

      <div class="row">
        <a class="btn btn-ghost" href="index.html">Back to AHSS</a>
        <a class="btn btn-ghost" href="AYPT.html">Open AYPT</a>
      </div>
    </div>

    <div class="grid">
      <!-- LEFT: Controls -->
      <div class="controls">
        <div class="card">
          <div class="card-h">
            <h2>Entrants</h2>
            <div class="tiny">Paste, edit, or load from AYPT sheet</div>
          </div>
          <div class="card-b">
            <div class="row">
              <button class="btn btn-primary" id="btnLoadAYPT">Load from AYPT Sheet</button>
              <button class="btn" id="btnClear">Clear</button>
            </div>

            <div style="margin-top:12px;">
              <label for="entrantsBox">One name per line</label>
              <textarea id="entrantsBox" placeholder="Example:
Sammy Mora
Connor Cummings
Brian Q
..."></textarea>
              <div class="pillbar" id="entrantPills"></div>
              <div class="status" id="status">Ready.</div>
            </div>

            <div style="margin-top:12px;" class="note">
              Tip - after loading, hit <span class="kbd">Build bracket</span>. You can still edit names before building.
            </div>
          </div>
        </div>

        <div class="card">
          <div class="card-h">
            <h2>Bracket Options</h2>
          </div>
          <div class="card-b">
            <div class="row">
              <div style="flex:1; min-width:160px;">
                <label for="seedMode">Seeding</label>
                <select id="seedMode">
                  <option value="random">Random (shuffle)</option>
                  <option value="alpha">Alphabetical</option>
                </select>
              </div>

              <div style="flex:1; min-width:160px;">
                <label for="maxPlayers">Max players</label>
                <input id="maxPlayers" type="number" min="2" max="64" step="1" value="16" />
              </div>
            </div>

            <div class="row" style="margin-top:10px;">
              <button class="btn btn-primary" id="btnBuild">Build bracket</button>
              <button class="btn" id="btnResetResults">Reset results</button>
            </div>

            <div class="status" id="buildInfo" style="margin-top:10px;">
              Double elim - creates Winners + Losers lanes and a Grand Final shell. (This is a practical TD view, not a perfect PDF bracket.)
            </div>
          </div>
        </div>
      </div>

      <!-- RIGHT: Bracket -->
      <div class="card">
        <div class="card-h">
          <h2>Bracket</h2>
          <div class="tiny">Tap scores - click “Win” to advance</div>
        </div>
        <div class="card-b bracket-wrap">
          <div id="bracketRoot">
            <div class="status">No bracket yet - load entrants and click Build bracket.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="footerbar">
    <div class="left">
      <div><strong>Controls</strong> - click score boxes to type. Use Win button to advance.</div>
      <div class="tiny">This is built to be fast for tonight - not a full bracket publishing system (yet).</div>
    </div>
    <div class="right">
      <button class="btn" id="btnExportJSON">Export JSON</button>
      <button class="btn" id="btnImportJSON">Import JSON</button>
      <button class="btn" id="btnExportResults">Export Results (CSV)</button>
    </div>
  </div>

  <script>
    // =========================================================
    // AYPT SHEET CONFIG (same endpoint as AYPT.html)
    // =========================================================
    const AYPT_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbzoQ7YLUs_S1pi8mQCc7u__44wf7TRZd9k40vKfPBQi4mTBYt5tZPcI9PR5Hx7E0BRU/exec";

    // JSONP helper (avoids CORS) - same approach as AYPT.html
    function jsonp(url, params = {}, timeoutMs = 12000){
      return new Promise((resolve, reject) => {
        const cb = "BRACKETS_CB_" + Math.random().toString(36).slice(2);
        params.callback = cb;
        const qs = new URLSearchParams(params).toString();

        const s = document.createElement("script");
        s.src = `${url}?${qs}`;
        s.id  = cb;

        const timeout = setTimeout(() => { cleanup(); reject(new Error("JSONP timeout")); }, timeoutMs);
        window[cb] = (data) => { cleanup(); resolve(data); };

        function cleanup(){
          clearTimeout(timeout);
          const el = document.getElementById(cb);
          if(el) el.remove();
          try { delete window[cb]; } catch(_) { window[cb] = undefined; }
        }
        document.body.appendChild(s);
      });
    }

    // =========================================================
    // Theme + logo helpers (reuse AHSS behavior lightly)
    // =========================================================
    const THEME_KEYS = {
      A:'ahss_theme_teamA',
      B:'ahss_theme_teamB',
      LOGO:'ahss_custom_logo_data'
    };

    function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
    function setCssVar(name, value){ document.documentElement.style.setProperty(name, value); }

    function applySavedTheme(){
      const a = localStorage.getItem(THEME_KEYS.A);
      const b = localStorage.getItem(THEME_KEYS.B);
      if(a) setCssVar('--teamA', a);
      if(b) setCssVar('--teamB', b);
      const storedLogo = localStorage.getItem(THEME_KEYS.LOGO);
      const img = document.getElementById('appLogo');
      if(storedLogo && img) img.src = storedLogo;
    }

    // =========================================================
    // Entrant editing UX
    // =========================================================
    const entrantsBox = document.getElementById('entrantsBox');
    const entrantPills = document.getElementById('entrantPills');
    const statusEl = document.getElementById('status');

    function parseEntrants(){
      const raw = (entrantsBox.value || '').split('\n').map(s=>s.trim()).filter(Boolean);
      // de-dupe case-insensitive
      const out = [];
      const seen = new Set();
      for(const n of raw){
        const k = n.toLowerCase();
        if(seen.has(k)) continue;
        seen.add(k);
        out.push(n);
      }
      return out;
    }

    function updateEntrantPills(){
      const list = parseEntrants();
      entrantPills.innerHTML = '';
      list.forEach((name, idx) => {
        const pill = document.createElement('div');
        pill.className = 'pill';
        pill.innerHTML = `<span>${escapeHtml(name)}</span><span class="x" title="Remove">×</span>`;
        pill.querySelector('.x').addEventListener('click', () => {
          const cur = parseEntrants();
          cur.splice(idx, 1);
          entrantsBox.value = cur.join('\n');
          updateEntrantPills();
        });
        entrantPills.appendChild(pill);
      });
      statusEl.textContent = `${list.length} entrant(s) in box.`;
    }

    entrantsBox.addEventListener('input', () => updateEntrantPills());

    // =========================================================
    // Load from AYPT Sheet (JSONP list=1)
    // =========================================================
    async function loadFromAYPT(){
      statusEl.textContent = "Loading from AYPT Google Sheet…";

      try{
        const data = await jsonp(AYPT_SCRIPT_URL, { list: "1" });
        if(!data || !data.ok) throw new Error((data && data.message) || "Load failed");

        const rows = data.rows || [];
        if(!rows.length){
          statusEl.textContent = "AYPT sheet returned 0 rows.";
          return;
        }

        // Build names from fields: firstName / lastName (as used in your AYPT admin UI)
        const names = rows
          .map(r => `${String(r.firstName || "").trim()} ${String(r.lastName || "").trim()}`.trim())
          .filter(n => n && n !== "");

        // Optional: paid-only
        // const names = rows
        //   .filter(r => !!r.paid)
        //   .map(r => `${String(r.firstName||"").trim()} ${String(r.lastName||"").trim()}`.trim())
        //   .filter(Boolean);

        // De-dupe case-insensitive
        const out = [];
        const seen = new Set();
        for(const n of names){
          const key = n.toLowerCase();
          if(seen.has(key)) continue;
          seen.add(key);
          out.push(n);
        }

        entrantsBox.value = out.join('\n');
        updateEntrantPills();
        statusEl.textContent = `Loaded ${out.length} players from AYPT Sheet. Tap "Build bracket".`;
      } catch(err){
        console.error(err);
        statusEl.textContent = `Failed to load from AYPT Sheet: ${err.message || err}`;
      }
    }

    // =========================================================
    // Bracket engine (practical double-elim shell)
    // =========================================================
    const bracketRoot = document.getElementById('bracketRoot');
    const seedModeEl = document.getElementById('seedMode');
    const maxPlayersEl = document.getElementById('maxPlayers');

    // State saved for export/import
    let BRACKET_STATE = null;

    function nextPow2(n){
      let p = 1;
      while(p < n) p <<= 1;
      return p;
    }

    function seededList(list, mode){
      const a = [...list];
      if(mode === 'alpha'){
        a.sort((x,y)=>x.localeCompare(y));
      } else {
        shuffle(a);
      }
      return a;
    }

    function shuffle(a){
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function makeMatch(id, label, p1=null, p2=null){
      return {
        id,
        label,
        p1, p2,
        s1: "",
        s2: "",
        winner: null, // 'p1' or 'p2'
        loser: null
      };
    }

    function buildBracket(){
      const entrants = parseEntrants();
      const maxP = clamp(parseInt(maxPlayersEl.value||"16",10), 2, 64);
      const trimmed = entrants.slice(0, maxP);

      if(trimmed.length < 2){
        bracketRoot.innerHTML = `<div class="status">Need at least 2 entrants.</div>`;
        return;
      }

      const seeded = seededList(trimmed, seedModeEl.value);
      const bracketSize = nextPow2(seeded.length);
      const byes = bracketSize - seeded.length;

      const slots = [...seeded];
      for(let i=0;i<byes;i++) slots.push("BYE");

      // Winners Round 1 matches
      const wr1 = [];
      for(let i=0;i<bracketSize;i+=2){
        const m = makeMatch(`W1-${i/2+1}`, `W R1 - M${i/2+1}`, slots[i], slots[i+1]);
        wr1.push(m);
      }

      // Winners Round 2+ (shell only, we will populate as winners advance)
      const winnersRounds = [];
      winnersRounds.push(wr1);

      let roundSize = wr1.length;
      let r = 2;
      while(roundSize > 1){
        roundSize = Math.ceil(roundSize/2);
        const round = [];
        for(let i=0;i<roundSize;i++){
          round.push(makeMatch(`W${r}-${i+1}`, `W R${r} - M${i+1}`));
        }
        winnersRounds.push(round);
        r++;
      }

      // Losers (shell) - not exact bracket mapping for every bracket size,
      // but practical: a lane of matches that fills with losers as play proceeds.
      // We'll create enough loser rounds to keep it usable.
      const losersRounds = [];
      const loserRoundsCount = Math.max(2, (winnersRounds.length - 1) * 2);
      for(let lr=1; lr<=loserRoundsCount; lr++){
        const count = Math.max(1, Math.ceil(bracketSize / Math.pow(2, Math.ceil(lr/2)+1)));
        const round = [];
        for(let i=0;i<count;i++){
          round.push(makeMatch(`L${lr}-${i+1}`, `L R${lr} - M${i+1}`));
        }
        losersRounds.push(round);
      }

      const gf1 = makeMatch("GF-1", "Grand Final", null, null);
      const gf2 = makeMatch("GF-2", "Grand Final Reset (if needed)", null, null);

      BRACKET_STATE = {
        createdAt: Date.now(),
        bracketSize,
        entrants: trimmed,
        seeded,
        winnersRounds,
        losersRounds,
        grandFinal: [gf1, gf2]
      };

      // Auto-advance BYE matches in W R1
      winnersRounds[0].forEach(m=>{
        if(m.p1 === "BYE" && m.p2 !== "BYE"){ setWinner(m, "p2", true); }
        else if(m.p2 === "BYE" && m.p1 !== "BYE"){ setWinner(m, "p1", true); }
      });

      renderBracket();
      document.getElementById('buildInfo').textContent =
        `Built for ${trimmed.length} players (bracket size ${bracketSize}, ${byes} bye(s)).`;
    }

    function renderBracket(){
      if(!BRACKET_STATE){
        bracketRoot.innerHTML = `<div class="status">No bracket yet.</div>`;
        return;
      }

      const { winnersRounds, losersRounds, grandFinal } = BRACKET_STATE;

      const bracketEl = document.createElement('div');
      bracketEl.className = 'bracket';

      // Winners columns
      winnersRounds.forEach((round, idx) => {
        const col = document.createElement('div');
        col.className = 'col';
        col.innerHTML = `<div class="col-title">Winners - Round ${idx+1}</div>`;
        round.forEach(m => col.appendChild(renderMatchCard(m, "W")));
        bracketEl.appendChild(col);
      });

      // Losers columns
      losersRounds.forEach((round, idx) => {
        const col = document.createElement('div');
        col.className = 'col';
        col.innerHTML = `<div class="col-title">Losers - Round ${idx+1}</div>`;
        round.forEach(m => col.appendChild(renderMatchCard(m, "L")));
        bracketEl.appendChild(col);
      });

      // Grand final column
      const gfCol = document.createElement('div');
      gfCol.className = 'col';
      gfCol.innerHTML = `<div class="col-title">Finals</div>`;
      grandFinal.forEach(m => gfCol.appendChild(renderMatchCard(m, "G")));
      bracketEl.appendChild(gfCol);

      bracketRoot.innerHTML = '';
      bracketRoot.appendChild(bracketEl);
    }

    function renderMatchCard(match, lane){
      const card = document.createElement('div');
      card.className = 'match';
      card.dataset.matchId = match.id;

      const tagText = lane === "W" ? "W" : lane === "L" ? "L" : "GF";
      card.innerHTML = `
        <div class="match-head">
          <div>${escapeHtml(match.label)}</div>
          <div class="tag">${tagText}</div>
        </div>
      `;

      const s1 = renderSlot(match, "p1");
      const s2 = renderSlot(match, "p2");
      card.appendChild(s1);
      card.appendChild(s2);

      const actions = document.createElement('div');
      actions.className = 'row';
      actions.style.marginTop = "10px";
      actions.innerHTML = `
        <button class="btn-mini btn-win" data-win="p1">Win - Top</button>
        <button class="btn-mini btn-win" data-win="p2">Win - Bottom</button>
        <button class="btn-mini btn-lose" data-clear="1">Clear</button>
      `;
      actions.querySelector('[data-win="p1"]').addEventListener('click', () => winMatch(match.id, "p1"));
      actions.querySelector('[data-win="p2"]').addEventListener('click', () => winMatch(match.id, "p2"));
      actions.querySelector('[data-clear="1"]').addEventListener('click', () => clearMatch(match.id));
      card.appendChild(actions);

      // Auto-disable win buttons if missing players
      const wp1 = actions.querySelector('[data-win="p1"]');
      const wp2 = actions.querySelector('[data-win="p2"]');
      if(!match.p1 || match.p1 === "BYE") wp1.disabled = true;
      if(!match.p2 || match.p2 === "BYE") wp2.disabled = true;

      return card;
    }

    function renderSlot(match, which){
      const slot = document.createElement('div');
      slot.className = 'slot';

      const name = (which === "p1" ? match.p1 : match.p2) || "TBD";
      const scoreKey = which === "p1" ? "s1" : "s2";

      if(match.winner === which) slot.classList.add('win');
      if(match.winner && match.winner !== which) slot.classList.add('lose');

      slot.innerHTML = `
        <div>
          <div class="name">${escapeHtml(name)}</div>
          <div class="seed">${escapeHtml(match.id)} - ${which.toUpperCase()}</div>
        </div>
        <input class="score" inputmode="numeric" pattern="[0-9]*" value="${escapeHtml(match[scoreKey])}" />
        <div></div>
      `;

      const scoreInput = slot.querySelector('.score');
      scoreInput.addEventListener('input', () => {
        match[scoreKey] = scoreInput.value.replace(/[^\d]/g,'').slice(0,2);
        saveState();
      });

      return slot;
    }

    // =========================================================
    // Advance logic (simple + usable)
    // =========================================================
    function findMatchById(id){
      if(!BRACKET_STATE) return null;
      const { winnersRounds, losersRounds, grandFinal } = BRACKET_STATE;
      for(const r of winnersRounds){
        for(const m of r) if(m.id === id) return m;
      }
      for(const r of losersRounds){
        for(const m of r) if(m.id === id) return m;
      }
      for(const m of grandFinal){
        if(m.id === id) return m;
      }
      return null;
    }

    function setWinner(match, which, silent=false){
      match.winner = which;
      match.loser = (which === "p1" ? "p2" : "p1");
      if(!silent) saveState();
    }

    function winMatch(matchId, which){
      const m = findMatchById(matchId);
      if(!m) return;

      // block nonsense
      const winnerName = (which === "p1" ? m.p1 : m.p2);
      const loserName  = (which === "p1" ? m.p2 : m.p1);
      if(!winnerName || winnerName === "TBD" || winnerName === "BYE") return;

      setWinner(m, which);

      // Determine lane type by ID prefix
      if(m.id.startsWith("W")){
        advanceInWinners(m, winnerName, loserName);
      } else if(m.id.startsWith("L")){
        advanceInLosers(m, winnerName, loserName);
      } else if(m.id.startsWith("GF")){
        advanceInFinals(m, winnerName, loserName);
      }

      renderBracket();
    }

    function clearMatch(matchId){
      const m = findMatchById(matchId);
      if(!m) return;
      m.s1 = "";
      m.s2 = "";
      m.winner = null;
      m.loser = null;
      saveState();
      renderBracket();
    }

    function advanceInWinners(match, winnerName, loserName){
      const { winnersRounds, losersRounds, grandFinal } = BRACKET_STATE;

      // Parse W{round}-{index}
      const mm = match.id.match(/^W(\d+)-(\d+)$/);
      if(!mm) return;
      const roundNum = parseInt(mm[1],10);
      const idx = parseInt(mm[2],10) - 1;

      // Winners advance to next winners round
      const nextRound = winnersRounds[roundNum]; // since roundNum is 1-based; next is index = roundNum
      if(nextRound){
        const nextIdx = Math.floor(idx/2);
        const target = nextRound[nextIdx];
        if(target){
          // Place into p1 if empty else p2
          if(!target.p1) target.p1 = winnerName;
          else if(!target.p2) target.p2 = winnerName;
        }
      } else {
        // Winner of winners bracket goes to Grand Final p1
        const gf = grandFinal[0];
        if(!gf.p1) gf.p1 = winnerName;
      }

      // Loser drops into first available Losers match slot (simple TD flow)
      const drop = findFirstAvailableSlot(losersRounds);
      if(drop){
        if(!drop.p1) drop.p1 = loserName;
        else if(!drop.p2) drop.p2 = loserName;
      }

      saveState();
    }

    function advanceInLosers(match, winnerName, loserName){
      const { losersRounds, grandFinal } = BRACKET_STATE;

      // Winner advances to next Losers round slot
      const mm = match.id.match(/^L(\d+)-(\d+)$/);
      if(!mm) return;
      const roundNum = parseInt(mm[1],10);
      const idx = parseInt(mm[2],10) - 1;

      const nextRound = losersRounds[roundNum]; // next is index = roundNum
      if(nextRound){
        const nextIdx = Math.floor(idx/2);
        const target = nextRound[nextIdx];
        if(target){
          if(!target.p1) target.p1 = winnerName;
          else if(!target.p2) target.p2 = winnerName;
        }
      } else {
        // last loser winner goes to Grand Final p2
        const gf = grandFinal[0];
        if(!gf.p2) gf.p2 = winnerName;
      }

      // Loser is eliminated (no further action)
      saveState();
    }

    function advanceInFinals(match, winnerName, loserName){
      const { grandFinal } = BRACKET_STATE;
      // GF-1: if losers bracket winner beats winners bracket champ, trigger reset GF-2
      // GF-2: winner is champion
      if(match.id === "GF-1"){
        // If p2 wins (losers champ beats winners champ), schedule reset match with same players
        // If p1 wins, champion done.
        if(match.winner === "p2"){
          const reset = grandFinal[1];
          reset.p1 = match.p1;
          reset.p2 = match.p2;
        } else {
          // champion, clear reset
          grandFinal[1].p1 = null;
          grandFinal[1].p2 = null;
          grandFinal[1].winner = null;
          grandFinal[1].loser = null;
          grandFinal[1].s1 = "";
          grandFinal[1].s2 = "";
        }
      }
      saveState();
    }

    function findFirstAvailableSlot(rounds){
      for(const r of rounds){
        for(const m of r){
          if(!m.p1 || !m.p2) return m;
        }
      }
      return null;
    }

    // =========================================================
    // Export / Import
    // =========================================================
    function saveState(){
      try{
        localStorage.setItem('ahss_brackets_state', JSON.stringify(BRACKET_STATE));
      }catch(e){
        // ignore
      }
    }

    function loadState(){
      try{
        const raw = localStorage.getItem('ahss_brackets_state');
        if(!raw) return false;
        const s = JSON.parse(raw);
        if(!s || !s.winnersRounds) return false;
        BRACKET_STATE = s;
        return true;
      }catch(e){
        return false;
      }
    }

    function exportJSON(){
      if(!BRACKET_STATE){
        alert('No bracket to export.');
        return;
      }
      const blob = new Blob([JSON.stringify(BRACKET_STATE, null, 2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `AHSS_Brackets_${new Date().toISOString().slice(0,10)}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function importJSON(){
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'application/json';
      input.onchange = async () => {
        const file = input.files && input.files[0];
        if(!file) return;
        try{
          const text = await file.text();
          const s = JSON.parse(text);
          if(!s || !s.winnersRounds) throw new Error('Not a brackets export');
          BRACKET_STATE = s;
          saveState();
          renderBracket();
          document.getElementById('buildInfo').textContent = 'Imported bracket state.';
        }catch(e){
          alert('Import failed: ' + (e.message || e));
        }
      };
      input.click();
    }

    // =========================================================
    // Utilities
    // =========================================================
    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
    function escapeHtml(s){
      return String(s ?? "")
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;")
        .replace(/"/g,"&quot;")
        .replace(/'/g,"&#39;");
    }

    // =========================================================
    // Buttons wiring
    // =========================================================
    document.getElementById('btnLoadAYPT').addEventListener('click', loadFromAYPT);
    document.getElementById('btnClear').addEventListener('click', () => {
      entrantsBox.value = '';
      updateEntrantPills();
    });

    document.getElementById('btnBuild').addEventListener('click', () => {
      buildBracket();
      saveState();
    });

    document.getElementById('btnResetResults').addEventListener('click', () => {
      if(!BRACKET_STATE) return;
      if(!confirm('Reset all match results (scores + winners) but keep bracket structure?')) return;

      const wipe = (m) => { m.s1=""; m.s2=""; m.winner=null; m.loser=null; };

      BRACKET_STATE.winnersRounds.forEach(r=>r.forEach(wipe));
      BRACKET_STATE.losersRounds.forEach(r=>r.forEach(wipe));
      BRACKET_STATE.grandFinal.forEach(wipe);

      saveState();
      renderBracket();
    });

    document.getElementById('btnExportJSON').addEventListener('click', exportJSON);
    document.getElementById('btnImportJSON').addEventListener('click', importJSON);
    document.getElementById('btnExportResults').addEventListener('click', exportResultsCSV);

    function getChampionData(){
  if(!BRACKET_STATE || !BRACKET_STATE.grandFinal) return null;

  const gf1 = BRACKET_STATE.grandFinal[0];
  const gf2 = BRACKET_STATE.grandFinal[1];

  // If GF-2 has players and a winner, that overrides GF-1
  const finalMatch = (gf2 && gf2.p1 && gf2.p2 && gf2.winner) ? gf2 : (gf1 && gf1.winner ? gf1 : null);
  if(!finalMatch) return null;

  const champ = finalMatch.winner === "p1" ? finalMatch.p1 : finalMatch.p2;
  const runner = finalMatch.winner === "p1" ? finalMatch.p2 : finalMatch.p1;

  return { champ, runner, finalMatchId: finalMatch.id };
}

function collectEliminations(){
  // We treat "loser of any L-match" as eliminated (simple + practical).
  // This yields a usable elimination order for placements like 3rd/4th/etc.
  if(!BRACKET_STATE) return [];

  const elim = [];
  const pushElim = (m) => {
    if(!m || !m.winner || !m.loser) return;
    const loserName = (m.loser === "p1" ? m.p1 : m.p2);
    const winnerName = (m.winner === "p1" ? m.p1 : m.p2);
    if(!loserName || loserName === "BYE" || loserName === "TBD") return;
    elim.push({
      name: loserName,
      eliminatedBy: winnerName || "",
      matchId: m.id || "",
      when: Date.now()
    });
  };

  // Losers bracket eliminations
  (BRACKET_STATE.losersRounds || []).forEach(r => r.forEach(pushElim));

  // De-dupe (keep last occurrence)
  const map = new Map();
  elim.forEach(e => map.set(e.name.toLowerCase(), e));
  return Array.from(map.values());
}

function buildPlacements(){
  if(!BRACKET_STATE) return [];

  const entrants = (BRACKET_STATE.entrants || []).filter(n => n && n !== "BYE");
  const champData = getChampionData();

  // Default placements list
  const placements = [];

  if(champData && champData.champ){
    placements.push({ place: 1, name: champData.champ });
  }
  if(champData && champData.runner){
    placements.push({ place: 2, name: champData.runner });
  }

  // Remaining placements by “latest eliminations first”
  const eliminated = collectEliminations();

  // Remove champ/runner if present
  const taken = new Set((placements.map(p => p.name.toLowerCase())));
  const remainingElims = eliminated
    .filter(e => !taken.has(e.name.toLowerCase()))
    .reverse(); // last eliminated = higher placement

  let nextPlace = placements.length + 1;
  for(const e of remainingElims){
    placements.push({ place: nextPlace++, name: e.name, eliminatedBy: e.eliminatedBy, matchId: e.matchId });
  }

  // Add anyone never eliminated / never placed (in-progress or edge cases)
  const placedSet = new Set(placements.map(p => p.name.toLowerCase()));
  const leftovers = entrants.filter(n => !placedSet.has(n.toLowerCase()));
  for(const n of leftovers){
    placements.push({ place: nextPlace++, name: n, note: "No elimination recorded (in progress?)" });
  }

  return placements;
}

function exportResultsCSV(){
  if(!BRACKET_STATE){
    alert("No bracket loaded.");
    return;
  }

  const placements = buildPlacements();
  const champData = getChampionData();

  // If no champion yet, still export what we have.
  const header = ["Place","Player","Eliminated By","Match Id","Note"];
  const lines = [header.join(",")];

  for(const p of placements){
    const row = [
      p.place ?? "",
      csvCell(p.name ?? ""),
      csvCell(p.eliminatedBy ?? ""),
      csvCell(p.matchId ?? ""),
      csvCell(p.note ?? "")
    ];
    lines.push(row.join(","));
  }

  // Add a little meta footer as comments (CSV-safe)
  lines.push("");
  lines.push(csvCell("# BracketSize: " + (BRACKET_STATE.bracketSize || "")));
  lines.push(csvCell("# Created: " + new Date(BRACKET_STATE.createdAt || Date.now()).toLocaleString()));
  lines.push(csvCell("# ChampionKnown: " + (!!(champData && champData.champ))));

  const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `AHSS_Tournament_Results_${new Date().toISOString().slice(0,10)}.csv`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function csvCell(v){
  const s = String(v ?? "");
  if(/[,"\n]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
  return s;
}

    // =========================================================
    // Init
    // =========================================================
    document.addEventListener('DOMContentLoaded', () => {
      applySavedTheme();

      // Restore entrants from last session (optional)
      const last = localStorage.getItem('ahss_brackets_entrants');
      if(last){
        entrantsBox.value = last;
      }
      updateEntrantPills();

      entrantsBox.addEventListener('change', () => {
        localStorage.setItem('ahss_brackets_entrants', entrantsBox.value || '');
      });

      // Load existing bracket state if present
      if(loadState()){
        renderBracket();
        document.getElementById('buildInfo').textContent = 'Restored bracket state from this device.';
      }
    });
  </script>

  <div style="text-align:center; margin-top:22px; padding-bottom:80px; color:rgba(255,255,255,.45); font-size:12px;">
    v1.0 - brackets.html (AHSS)
  </div>
</body>
</html>
