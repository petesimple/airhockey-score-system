<!-- brackets.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
  <meta name="theme-color" content="#121212">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>AHSS - Double Elimination Brackets</title>

  <style>
    :root{
      --teamA:#d32f2f;
      --teamB:#1976d2;

      --bg:#121212;
      --panel:#0f0f10;
      --panel2:#0b0b0c;
      --line:#2a2a2a;
      --text:#f0f0f0;
      --muted:#a9a9a9;

      --good:#33d17a;
      --warn:#f2c94c;
      --bad:#ff5a5f;

      --radius:14px;
      --shadow:0 10px 28px rgba(0,0,0,.45);
    }

    *{ box-sizing:border-box; }
    html, body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: Arial, sans-serif;
      padding:16px;
      touch-action: manipulation;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      margin-bottom:12px;
    }

    .brand{
      display:flex;
      align-items:center;
      gap:12px;
      min-width:260px;
    }
    .brand img{
      height:44px;
      width:auto;
      object-fit:contain;
      filter: drop-shadow(0 6px 14px rgba(0,0,0,.6));
    }
    .brand h1{
      margin:0;
      font-size:18px;
      line-height:1.1;
    }
    .brand small{
      display:block;
      margin-top:2px;
      color:var(--muted);
      font-size:12px;
    }

    .actions{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }

    button{
      border:none;
      border-radius:12px;
      padding:10px 12px;
      background:#1f1f1f;
      color:#fff;
      cursor:pointer;
      border:1px solid #333;
      box-shadow: 0 8px 22px rgba(0,0,0,.35);
      font-weight:700;
    }
    button:hover{ filter:brightness(1.06); }
    button:active{ transform:translateY(1px); }
    .btn-primary{ background:linear-gradient(180deg, #262626, #161616); border-color:#3a3a3a; }
    .btn-good{ background:linear-gradient(180deg, rgba(51,209,122,.25), rgba(51,209,122,.10)); border-color:rgba(51,209,122,.35); }
    .btn-warn{ background:linear-gradient(180deg, rgba(242,201,76,.22), rgba(242,201,76,.10)); border-color:rgba(242,201,76,.35); }
    .btn-bad{ background:linear-gradient(180deg, rgba(255,90,95,.22), rgba(255,90,95,.10)); border-color:rgba(255,90,95,.35); }

    .layout{
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
    }

    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .panel .hd{
      padding:12px 12px;
      border-bottom:1px solid #1d1d1d;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      background:rgba(0,0,0,.25);
    }
    .panel .hd strong{ font-size:14px; }
    .panel .bd{ padding:12px; }

    textarea{
      width:100%;
      min-height:220px;
      resize:vertical;
      border-radius:12px;
      padding:10px;
      border:1px solid #2f2f2f;
      background:#0b0b0c;
      color:#fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px;
      line-height:1.35;
    }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-top:10px;
    }
    .row .pill{
      padding:6px 10px;
      border:1px solid #2a2a2a;
      border-radius:999px;
      color:#ddd;
      background:#101010;
      font-size:12px;
    }
    .hint{
      color:var(--muted);
      font-size:12px;
      margin-top:8px;
      line-height:1.35;
    }
    .hint a{ color:#9fb0c7; text-decoration:none; }

    .status{
      margin-top:10px;
      padding:10px 12px;
      border:1px dashed rgba(255,255,255,.18);
      border-radius:12px;
      background:rgba(255,255,255,.03);
      color:#ddd;
      font-size:12px;
      line-height:1.35;
      white-space:pre-wrap;
    }

    /* Bracket area */
    .bracketWrap{
      overflow:auto;
      padding:12px;
    }

    .bracketGrid{
      display:grid;
      gap:14px;
      align-items:start;
      min-width: 980px;
    }

    .col{
      display:flex;
      flex-direction:column;
      gap:12px;
      min-width:240px;
    }

    .colTitle{
      font-weight:900;
      letter-spacing:.3px;
      font-size:12px;
      color:#d9d9d9;
      padding:8px 10px;
      border:1px solid #2a2a2a;
      border-radius:12px;
      background:#0f0f10;
      text-transform:uppercase;
    }

    .match{
      border:1px solid #2c2c2c;
      border-radius:14px;
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,.15));
      box-shadow:0 10px 22px rgba(0,0,0,.25);
      overflow:hidden;
    }
    .match .mh{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border-bottom:1px solid #222;
      background:rgba(0,0,0,.25);
      font-size:12px;
      color:#d7d7d7;
    }
    .match .mh .tag{
      padding:3px 8px;
      border-radius:999px;
      border:1px solid #2a2a2a;
      background:#111;
      color:#ddd;
      font-weight:800;
      font-size:11px;
    }
    .match .mh .note{
      color:#9aa1aa;
      font-weight:700;
      font-size:11px;
    }

    .slot{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:10px 10px;
      gap:10px;
      cursor:pointer;
      user-select:none;
    }
    .slot + .slot{ border-top:1px solid #1f1f1f; }
    .slot:hover{ background:rgba(255,255,255,.04); }

    .name{
      display:flex;
      gap:8px;
      align-items:center;
      min-width:0;
    }
    .seed{
      font-weight:900;
      font-size:11px;
      width:34px;
      text-align:center;
      padding:4px 6px;
      border-radius:10px;
      border:1px solid #2a2a2a;
      background:#0f0f10;
      color:#bbb;
      flex:0 0 auto;
    }
    .player{
      font-weight:900;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 155px;
    }
    .sub{
      display:block;
      font-weight:700;
      color:#a7a7a7;
      font-size:11px;
      margin-top:2px;
    }

    .result{
      display:flex;
      gap:8px;
      align-items:center;
      flex:0 0 auto;
    }
    .score{
      width:64px;
      text-align:center;
      border-radius:10px;
      border:1px solid #2a2a2a;
      background:#0b0b0c;
      color:#fff;
      padding:6px 8px;
      font-weight:900;
      font-size:12px;
      outline:none;
    }

    .slot.win{
      background: rgba(51,209,122,.10);
    }
    .slot.win .seed{
      border-color: rgba(51,209,122,.35);
      color: #dff7ea;
    }
    .slot.win .player{ color:#dff7ea; }
    .slot.lose{
      opacity:.72;
    }

    .finalBadge{
      display:flex;
      align-items:center;
      gap:8px;
      font-weight:900;
      color:#fff;
    }
    .dot{
      width:10px;
      height:10px;
      border-radius:50%;
      background: var(--warn);
      box-shadow:0 0 10px rgba(242,201,76,.35);
    }

    .miniNote{
      font-size:11px;
      color:#9aa1aa;
      margin-top:8px;
      line-height:1.35;
    }

    .dangerLine{
      margin-top:10px;
      font-size:12px;
      color:#ffd7d7;
      background: rgba(255,90,95,.08);
      border: 1px solid rgba(255,90,95,.25);
      padding:10px 12px;
      border-radius:12px;
      display:none;
    }

    .footer{
      margin-top:14px;
      color:#777;
      font-size:12px;
      text-align:center;
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="brand">
      <img id="appLogo" src="logo.png" alt="AHSS logo" />
      <div>
        <h1>Double Elimination Brackets</h1>
        <small>Build from AYPT signups, then tap winners to advance.</small>
      </div>
    </div>

    <div class="actions">
      <button class="btn-primary" onclick="openAYPT()">Open AYPT</button>
      <button class="btn-warn" onclick="loadFromAYPT()">Load tonight from AYPT</button>
      <button class="btn-good" onclick="buildBracket()">Build bracket</button>
      <button class="btn-bad" onclick="resetAll()">Reset</button>
    </div>
  </div>

  <div class="layout">
    <!-- Left: Entrants -->
    <div class="panel">
      <div class="hd">
        <strong>Entrants</strong>
        <span class="pill" id="countPill">0 players</span>
      </div>
      <div class="bd">
        <textarea id="entrantsBox" placeholder="One player per line&#10;&#10;Tip: click Load tonight from AYPT (same device)"></textarea>

        <div class="row">
          <span class="pill" id="sizePill">Bracket size: -</span>
          <span class="pill" id="byePill">Byes: -</span>
        </div>

        <div class="hint">
          - AYPT sync method (easy mode): players sign up on <a href="AYPT.html">AYPT.html</a> on this device, then you load here. <br>
          - Tap a player line inside a match to mark them winner. That advances winner + drops loser appropriately.
        </div>

        <div id="warnBox" class="dangerLine"></div>

        <div id="status" class="status">No bracket yet. Paste names or load from AYPT.</div>

        <div class="miniNote">
          Notes:
          - Works best for 2, 4, 8, 16, 32 players. Non-power-of-two gets BYEs.
          - Grand Final has an “if needed” reset match if the Losers champ beats the Winners champ.
        </div>
      </div>
    </div>

    <!-- Right: Bracket -->
    <div class="panel">
      <div class="hd">
        <strong>Bracket</strong>
        <span class="pill" id="tapHint">Tap winners to advance</span>
      </div>
      <div class="bracketWrap">
        <div id="bracketMount"></div>
      </div>
    </div>
  </div>

  <div class="footer">AHSS Brackets - local only (no network required)</div>

  <script>
    // =========================================================
    // AHSS theme/logo compatibility (shares keys with your main page)
    // =========================================================
    const THEME_KEYS = {
      A:'ahss_theme_teamA',
      B:'ahss_theme_teamB',
      LOGO:'ahss_custom_logo_data'
    };

    function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
    function setCssVar(name, value){ document.documentElement.style.setProperty(name, value); }

    function applySavedTheme(){
      const a = localStorage.getItem(THEME_KEYS.A);
      const b = localStorage.getItem(THEME_KEYS.B);
      if(a) setCssVar('--teamA', a);
      if(b) setCssVar('--teamB', b);
    }
    function applyCustomLogo(){
      const stored = localStorage.getItem(THEME_KEYS.LOGO);
      const img = document.getElementById('appLogo');
      img.src = stored || 'logo.png';
    }

    // =========================================================
    // AYPT local roster helpers (must match what you added to AYPT.html)
    // =========================================================
    function ayptKeyForToday(){
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const day = String(d.getDate()).padStart(2,'0');
      return `ahss_aypt_roster_${y}-${m}-${day}`;
    }

    function openAYPT(){
      location.href = 'AYPT.html';
    }

    function loadFromAYPT(){
      const key = ayptKeyForToday();
      const roster = JSON.parse(localStorage.getItem(key) || '[]');
      const status = document.getElementById('status');

      if(!roster.length){
        status.textContent =
          "No AYPT signups found for today on this device.\n\n" +
          "Fix:\n" +
          "1) Open AYPT.html on THIS device\n" +
          "2) Submit at least one signup\n" +
          "3) Come back and tap Load tonight from AYPT";
        return;
      }

      const names = roster
        .map(x => (x?.name || '').trim())
        .filter(Boolean);

      document.getElementById('entrantsBox').value = names.join('\n');
      status.textContent = `Loaded ${names.length} players from AYPT (today). Now tap Build bracket.`;
      updateEntrantPills();
    }

    // =========================================================
    // Bracket engine (double elimination, power-of-two padded)
    // - Generates WB rounds (single elim)
    // - Generates LB rounds (standard: 2k-2 rounds for n=2^k)
    // - Grand Final + Reset Final (if needed)
    // - Tap winner to set, auto-advances winner/loser downstream
    // =========================================================

    function nextPow2(n){
      let p = 1;
      while(p < n) p <<= 1;
      return p;
    }
    function log2Pow2(n){
      let k = 0;
      while((1 << k) < n) k++;
      return k;
    }

    // Match store
    let BRACKET = null;

    function uid(prefix){
      return prefix + '_' + Math.random().toString(16).slice(2) + '_' + Date.now().toString(16);
    }

    function normalizeNames(raw){
      const lines = (raw || '')
        .split('\n')
        .map(s => s.trim())
        .filter(Boolean);

      // de-dupe (case-insensitive) while preserving order
      const out = [];
      const seen = new Set();
      for(const n of lines){
        const key = n.toLowerCase();
        if(seen.has(key)) continue;
        seen.add(key);
        out.push(n);
      }
      return out;
    }

    function updateEntrantPills(){
      const names = normalizeNames(document.getElementById('entrantsBox').value);
      document.getElementById('countPill').textContent = `${names.length} players`;

      if(names.length < 2){
        document.getElementById('sizePill').textContent = 'Bracket size: -';
        document.getElementById('byePill').textContent = 'Byes: -';
        return;
      }
      const size = nextPow2(names.length);
      const byes = size - names.length;
      document.getElementById('sizePill').textContent = `Bracket size: ${size}`;
      document.getElementById('byePill').textContent = `Byes: ${byes}`;
    }

    document.getElementById('entrantsBox').addEventListener('input', updateEntrantPills);

    function buildBracket(){
      const warn = document.getElementById('warnBox');
      warn.style.display = 'none';
      warn.textContent = '';

      const names = normalizeNames(document.getElementById('entrantsBox').value);
      const status = document.getElementById('status');

      if(names.length < 2){
        warn.style.display = 'block';
        warn.textContent = 'Need at least 2 players.';
        status.textContent = 'Add at least 2 players, then Build bracket.';
        return;
      }

      const size = nextPow2(names.length);
      const byes = size - names.length;

      // Pad with BYE entries (not real players)
      const entrants = names.map((name, i) => ({ seed: i+1, name }));
      for(let i=0;i<byes;i++){
        entrants.push({ seed: names.length + i + 1, name: 'BYE', bye: true });
      }

      // Basic warning if huge
      if(size > 32){
        warn.style.display = 'block';
        warn.textContent = `Heads up: ${size} bracket is big. It still works, but scroll city.`;
      }

      BRACKET = createDoubleElimBracket(entrants, size);
      resolveAllAutoWins(BRACKET); // auto-advance BYEs
      renderBracket(BRACKET);

      status.textContent =
        `Built a ${size}-player double elimination bracket.\n` +
        `Tap winners inside matches to advance. BYEs auto-advance.`;
    }

    function resetAll(){
      if(!confirm('Reset bracket and clear all results?')) return;
      BRACKET = null;
      document.getElementById('bracketMount').innerHTML = '';
      document.getElementById('status').textContent = 'No bracket yet. Paste names or load from AYPT.';
    }

    // ---------- Bracket creation ----------
    // Reference format:
    //  { type:'seed', seed:number }
    //  { type:'winner', matchId:string }
    //  { type:'loser', matchId:string }
    function createMatch(label, bracket, roundIndex, matchIndex){
      return {
        id: uid(bracket + '_' + roundIndex + '_' + matchIndex),
        bracket,
        roundIndex,
        matchIndex,
        label,
        A: null,
        B: null,
        winner: null, // 'A' | 'B'
        scoreA: '',
        scoreB: ''
      };
    }

    function createDoubleElimBracket(entrants, size){
      const n = size;
      const k = log2Pow2(n);

      const matches = new Map();

      // Winners bracket rounds
      const WB = [];
      for(let r=1; r<=k; r++){
        const cnt = n / (1<<r); // n/2, n/4, ..., 1
        const round = [];
        for(let m=0; m<cnt; m++){
          const match = createMatch(`W${r}-M${m+1}`, 'W', r, m+1);
          round.push(match);
          matches.set(match.id, match);
        }
        WB.push(round);
      }

      // Seed into WB round 1
      // Pairing: (1 vs 2), (3 vs 4)... based on entrant list order
      // (If you want true seeding later: swap to 1vN etc)
      const first = WB[0];
      for(let i=0; i<first.length; i++){
        const e1 = entrants[i*2];
        const e2 = entrants[i*2+1];
        first[i].A = { type:'seed', seed: e1.seed };
        first[i].B = { type:'seed', seed: e2.seed };
      }

      // Link WB winners forward
      for(let r=2; r<=k; r++){
        const prev = WB[r-2];
        const cur  = WB[r-1];
        for(let i=0;i<cur.length;i++){
          cur[i].A = { type:'winner', matchId: prev[i*2].id };
          cur[i].B = { type:'winner', matchId: prev[i*2+1].id };
        }
      }

      // Losers bracket rounds: 2k-2 rounds
      const lbRoundsCount = Math.max(1, 2*k - 2);
      const LB = [];
      for(let i=1; i<=lbRoundsCount; i++){
        const stage = Math.min(Math.ceil(i/2) + 1, k); // good sizing behavior
        const cnt = n / (1<<stage);
        const round = [];
        for(let m=0; m<cnt; m++){
          const match = createMatch(`L${i}-M${m+1}`, 'L', i, m+1);
          round.push(match);
          matches.set(match.id, match);
        }
        LB.push(round);
      }

      // Wire LB:
      // - L1: losers from WB1 paired (1&2), (3&4), ...
      // - Even Li: winners from L(i-1) vs losers from WB(r) where r = i/2 + 1
      // - Odd Li>1: winners from L(i-1) paired
      for(let i=1; i<=lbRoundsCount; i++){
        const round = LB[i-1];
        if(i === 1){
          // losers from WB round1
          const wb1 = WB[0];
          // wb1 losers count = n/2; round match count = n/4; each needs 2 losers
          for(let m=0; m<round.length; m++){
            const src1 = wb1[m*2];
            const src2 = wb1[m*2+1];
            round[m].A = { type:'loser', matchId: src1.id };
            round[m].B = { type:'loser', matchId: src2.id };
          }
        } else if(i % 2 === 0){
          // even: winners from prev LB + losers from WB round r
          const prevLB = LB[i-2];
          const r = (i/2) + 1; // WB round index (1-based)
          const wbR = WB[r-1]; // may exist up to k
          for(let m=0; m<round.length; m++){
            const lbSrc = prevLB[m];
            const wbSrc = wbR[m];
            round[m].A = { type:'winner', matchId: lbSrc.id };
            round[m].B = { type:'loser',  matchId: wbSrc.id };
          }
        } else {
          // odd > 1: winners from prev LB paired
          const prevLB = LB[i-2];
          for(let m=0; m<round.length; m++){
            const src1 = prevLB[m*2];
            const src2 = prevLB[m*2+1];
            round[m].A = { type:'winner', matchId: src1.id };
            round[m].B = { type:'winner', matchId: src2.id };
          }
        }
      }

      // Grand Final + Reset Final
      const GF = createMatch('GF', 'F', 1, 1);
      const RF = createMatch('GF-RESET (if needed)', 'F', 2, 1);
      matches.set(GF.id, GF);
      matches.set(RF.id, RF);

      // GF: WB champ vs LB champ
      const wbFinal = WB[k-1][0];
      const lbFinal = LB[lbRoundsCount-1][0];

      GF.A = { type:'winner', matchId: wbFinal.id }; // Winners champ
      GF.B = { type:'winner', matchId: lbFinal.id }; // Losers champ

      // Reset Final: same two, but only relevant if GF winner is from Losers side
      RF.A = { type:'winner', matchId: GF.id };
      RF.B = { type:'loser',  matchId: GF.id };

      return {
        entrants, size:n, k,
        WB, LB,
        finals: [GF, RF],
        matches
      };
    }

    // ---------- Resolution / propagation ----------
    function getEntrantBySeed(br, seed){
      return br.entrants.find(e => e.seed === seed) || null;
    }

    function resolveRef(br, ref){
      if(!ref) return { name:'—', seed:'', bye:false, known:false };

      if(ref.type === 'seed'){
        const e = getEntrantBySeed(br, ref.seed);
        if(!e) return { name:'—', seed:'', bye:false, known:false };
        return {
          name: e.name,
          seed: e.seed,
          bye: !!e.bye,
          known: true
        };
      }

      const m = br.matches.get(ref.matchId);
      if(!m) return { name:'—', seed:'', bye:false, known:false };

      if(ref.type === 'winner'){
        if(m.winner === 'A') return resolveRef(br, m.A);
        if(m.winner === 'B') return resolveRef(br, m.B);
        return { name:'TBD', seed:'', bye:false, known:false };
      }

      if(ref.type === 'loser'){
        if(m.winner === 'A') return resolveRef(br, m.B);
        if(m.winner === 'B') return resolveRef(br, m.A);
        return { name:'TBD', seed:'', bye:false, known:false };
      }

      return { name:'—', seed:'', bye:false, known:false };
    }

    function setWinner(br, matchId, side){
      const m = br.matches.get(matchId);
      if(!m) return;

      // Can't pick winner if one side is unknown TBD
      const ra = resolveRef(br, m.A);
      const rb = resolveRef(br, m.B);

      // Allow BYE auto wins, but block clicking TBD
      if(side === 'A' && (!ra.known || ra.name === 'TBD')) return;
      if(side === 'B' && (!rb.known || rb.name === 'TBD')) return;

      // If opponent is BYE, force correct winner
      if(ra.name === 'BYE' && rb.name !== 'BYE') side = 'B';
      if(rb.name === 'BYE' && ra.name !== 'BYE') side = 'A';

      // Toggle off if same side clicked
      if(m.winner === side){
        m.winner = null;
      } else {
        m.winner = side;
      }

      // If this is Reset Final, it only matters if it becomes resolvable
      // After changes, resolve BYE auto wins again downstream.
      resolveAllAutoWins(br);

      // If GF winner is Losers champ, Reset match should become "active"
      // If GF winner is Winners champ, clear reset match winner if set.
      enforceGrandFinalLogic(br);

      renderBracket(br);
    }

    function enforceGrandFinalLogic(br){
      const GF = br.finals[0];
      const RF = br.finals[1];

      const gfA = resolveRef(br, GF.A); // winners champ
      const gfB = resolveRef(br, GF.B); // losers champ

      // If GF decided and winner == gfA (winners champ), reset is irrelevant -> clear it
      if(GF.winner){
        const gfWinner = (GF.winner === 'A') ? gfA : gfB;
        if(gfWinner.name === gfA.name){
          RF.winner = null;
          RF.scoreA = '';
          RF.scoreB = '';
        }
      }

      // If GF not decided, also clear reset
      if(!GF.winner){
        RF.winner = null;
        RF.scoreA = '';
        RF.scoreB = '';
      }
    }

    function resolveAllAutoWins(br){
      // Iterate a few passes so downstream becomes resolvable
      for(let pass=0; pass<6; pass++){
        let changed = false;

        for(const m of br.matches.values()){
          const a = resolveRef(br, m.A);
          const b = resolveRef(br, m.B);

          // If either side is BYE and the other is known non-BYE -> auto-win
          if(a.known && b.known){
            if(a.name === 'BYE' && b.name !== 'BYE'){
              if(m.winner !== 'B'){ m.winner = 'B'; changed = true; }
            }
            if(b.name === 'BYE' && a.name !== 'BYE'){
              if(m.winner !== 'A'){ m.winner = 'A'; changed = true; }
            }
          }

          // If both are BYE (rare), clear
          if(a.known && b.known && a.name === 'BYE' && b.name === 'BYE'){
            if(m.winner){ m.winner = null; changed = true; }
          }
        }

        if(!changed) break;
      }

      enforceGrandFinalLogic(br);
    }

    // ---------- Rendering ----------
    function renderBracket(br){
      const mount = document.getElementById('bracketMount');
      if(!br){ mount.innerHTML = ''; return; }

      // Build columns:
      // Winners R1..Rk, Losers L1..L(2k-2), Finals
      const cols = [];

      for(let r=1; r<=br.k; r++){
        cols.push({ title: `Winners R${r}`, matches: br.WB[r-1] });
      }
      for(let i=1; i<=br.LB.length; i++){
        cols.push({ title: `Losers R${i}`, matches: br.LB[i-1] });
      }
      cols.push({ title: 'Finals', matches: br.finals });

      // Grid template columns
      const grid = document.createElement('div');
      grid.className = 'bracketGrid';
      grid.style.gridTemplateColumns = `repeat(${cols.length}, minmax(240px, 240px))`;

      cols.forEach((c, colIdx) => {
        const col = document.createElement('div');
        col.className = 'col';

        const t = document.createElement('div');
        t.className = 'colTitle';

        if(c.title === 'Finals'){
          t.innerHTML = `<span class="finalBadge"><span class="dot"></span>${c.title}</span>`;
        } else {
          t.textContent = c.title;
        }

        col.appendChild(t);

        c.matches.forEach(m => {
          col.appendChild(renderMatch(br, m));
        });

        grid.appendChild(col);
      });

      mount.innerHTML = '';
      mount.appendChild(grid);

      updateLiveStatus(br);
    }

    function renderMatch(br, m){
      const card = document.createElement('div');
      card.className = 'match';

      const mh = document.createElement('div');
      mh.className = 'mh';

      const tag = document.createElement('span');
      tag.className = 'tag';
      tag.textContent = m.label;

      const note = document.createElement('span');
      note.className = 'note';

      // Special note for reset final
      if(m.label.includes('RESET')){
        const gf = br.finals[0];
        if(!gf.winner){
          note.textContent = 'Waiting for GF';
        } else {
          // Active only if GF winner was Losers champ
          const gfA = resolveRef(br, gf.A);
          const gfB = resolveRef(br, gf.B);
          const gfWinner = (gf.winner === 'A') ? gfA : gfB;
          if(gfWinner.name === gfA.name){
            note.textContent = 'Not needed';
          } else {
            note.textContent = 'If needed';
          }
        }
      } else {
        note.textContent = 'tap winner';
      }

      mh.appendChild(tag);
      mh.appendChild(note);
      card.appendChild(mh);

      const a = resolveRef(br, m.A);
      const b = resolveRef(br, m.B);

      card.appendChild(renderSlot(br, m, 'A', a));
      card.appendChild(renderSlot(br, m, 'B', b));

      return card;
    }

    function renderSlot(br, m, side, info){
      const slot = document.createElement('div');
      slot.className = 'slot';

      const other = (side === 'A') ? 'B' : 'A';

      if(m.winner === side) slot.classList.add('win');
      if(m.winner === other) slot.classList.add('lose');

      slot.addEventListener('click', () => setWinner(br, m.id, side));

      const left = document.createElement('div');
      left.className = 'name';

      const seed = document.createElement('div');
      seed.className = 'seed';
      seed.textContent = info.seed ? `#${info.seed}` : '—';

      const nm = document.createElement('div');
      nm.style.minWidth = '0';

      const player = document.createElement('div');
      player.className = 'player';
      player.textContent = info.name || '—';

      const sub = document.createElement('span');
      sub.className = 'sub';

      if(info.name === 'BYE'){
        sub.textContent = 'auto-advance';
        seed.style.borderColor = 'rgba(242,201,76,.35)';
        seed.style.color = '#ffe7a0';
      } else if(info.name === 'TBD'){
        sub.textContent = 'waiting on upstream';
      } else {
        sub.textContent = '';
      }

      nm.appendChild(player);
      nm.appendChild(sub);

      left.appendChild(seed);
      left.appendChild(nm);

      const right = document.createElement('div');
      right.className = 'result';

      const score = document.createElement('input');
      score.className = 'score';
      score.placeholder = 'score';
      score.inputMode = 'text';
      score.value = (side === 'A') ? (m.scoreA || '') : (m.scoreB || '');

      score.addEventListener('click', (e)=> e.stopPropagation());
      score.addEventListener('input', ()=>{
        if(side === 'A') m.scoreA = score.value;
        else m.scoreB = score.value;
      });

      right.appendChild(score);

      slot.appendChild(left);
      slot.appendChild(right);

      // Color hinting for WB/LB labels (tiny flourish)
      if(m.bracket === 'W'){
        slot.style.borderLeft = `6px solid ${cssVar('--teamA')}`;
      } else if(m.bracket === 'L'){
        slot.style.borderLeft = `6px solid ${cssVar('--teamB')}`;
      } else {
        slot.style.borderLeft = `6px solid var(--warn)`;
      }

      return slot;
    }

    function updateLiveStatus(br){
      const status = document.getElementById('status');

      const total = Array.from(br.matches.values()).length;
      const decided = Array.from(br.matches.values()).filter(m => !!m.winner).length;

      const gf = br.finals[0];
      const rf = br.finals[1];

      const gfA = resolveRef(br, gf.A);
      const gfB = resolveRef(br, gf.B);

      let champLine = '';
      if(rf.winner){
        const rfa = resolveRef(br, rf.A);
        const rfb = resolveRef(br, rf.B);
        const champ = (rf.winner === 'A') ? rfa : rfb;
        champLine = `Champion: ${champ.name}\n`;
      } else if(gf.winner){
        const gfw = (gf.winner === 'A') ? gfA : gfB;
        // If GF winner is winners champ, that's champion; else reset needed
        if(gfw.name === gfA.name){
          champLine = `Champion: ${gfw.name}\n`;
        } else {
          champLine = `GF won by Losers champ (${gfw.name}). Reset match required.\n`;
        }
      }

      status.textContent =
        `${champLine}` +
        `Progress: ${decided}/${total} matches decided.\n` +
        `Winners champ slot: ${gfA.name}\n` +
        `Losers champ slot: ${gfB.name}\n` +
        `Tip: tap a player row in a match to set winner (tap again to clear).`;
    }

    // =========================================================
    // Boot
    // =========================================================
    document.addEventListener('DOMContentLoaded', ()=>{
      applySavedTheme();
      applyCustomLogo();
      updateEntrantPills();

      // If user already has entrants in storage from a prior session, leave it
      // (We don't auto-load AYPT to avoid confusion across devices.)
    });
  </script>
</body>
</html>
